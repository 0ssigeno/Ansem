package main

import (
	"context"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strings"
	"sync"
	"time"
	"regexp"
)

func StartExploiter(exploitCtx context.Context, wg *sync.WaitGroup) {
	//Every tick!
	defer wg.Done()
	tick := exploitCtx.Value("tick").(int)
	fileTeam := exploitCtx.Value("fileTeam").(string)
	exploitDir := exploitCtx.Value("exploitDir").(string)
	workers := exploitCtx.Value("workers").(int)
	toSubmit := exploitCtx.Value("submit").(chan string)
        flagRegex, err := regexp.Compile(exploitCtx.Value("flagRegex").(string))

	if err !=nil{
		log.Fatalf("EXPLOITER\tInvalid regexp\n")
	}

	for {
		now := time.Now()
		//Get the producer of the teams
		teams := GetTeamAsChan(fileTeam)
		// Read all files in directory
		files, err := ioutil.ReadDir(exploitDir)
		if err != nil {
			log.Fatalf("EXPLOITER\tError Exploit Dir\t%s\n",exploitDir)

		}
		//Init waitgroup to wait for children
		wg := sync.WaitGroup{}
		wg.Add(workers)
		//StartExploiter workers
		for i := 0; i < workers; i++ {
			go exploit(exploitDir, files, toSubmit, teams, &wg, flagRegex)
		}
		//Wait workers
		wg.Wait()
		//Stop until now+tick
		<-time.Tick(time.Until(now.Add(time.Duration(tick))))
	}
}

func exploit(exploitDir string, exploits []os.FileInfo, toSubmit chan<- string, teams <-chan string, wg *sync.WaitGroup, flagRegex *regexp.Regexp) {
	defer wg.Done()
	// Read from teams channel
	for team := range teams {
		// For every exploit
		for _, exploitInfo := range exploits {
			// Execute exploit and get output
			exploitName := exploitInfo.Name()
			exploitAbsPath := fmt.Sprintf("%s%s", exploitDir, exploitName)
			outFlags, err := exec.Command(exploitAbsPath, team).Output()
			if err != nil {
				log.Printf("EXPLOITER\tError Exploit:\t%s\nTrace:\n%s\n", exploitName, string(outFlags))
				return
			}
			//Test the format
			flags := strings.Split(string(outFlags), "\n")

			//Send the flags to the submitter goroutine!
			for _, flag := range flags {
				matched := flagRegex.MatchString(flag)
				if matched {
				      toSubmit <- flag
				} else {
					log.Printf("EXPLOITER\tRegex Error:\tTeam %s\tExploit %s\tFlag %s\n",team,exploitName,flag)
				}
			}
		}
	}
	return

}
