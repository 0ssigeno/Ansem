package main

import (
	"context"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strings"
	"sync"
	"time"
)

func StartExploiter(exploitCtx context.Context) {
	//Every tick!

	tick := exploitCtx.Value("tick").(int)
	fileTeam := exploitCtx.Value("fileTeam").(string)
	exploitDir := exploitCtx.Value("exploitDir").(string)
	workers := exploitCtx.Value("workers").(int)
	toSubmit := exploitCtx.Value("submit").(chan string)

	for range time.Tick(time.Duration(tick) * time.Second) {
		//Get the producer of the teams
		teams := GetTeamAsChan(fileTeam)
		// Read all files in directory
		files, err := ioutil.ReadDir(exploitDir)
		if err != nil {
			_, _ = fmt.Fprintf(os.Stderr, "Exploit dir %s doesn't exist!", exploitDir)
			os.Exit(1)

		}
		//Init waitgroup to wait for children
		wg := sync.WaitGroup{}
		wg.Add(workers)
		//StartExploiter workers
		for i := 0; i < workers; i++ {
			go func() {
				defer wg.Done()
				exploit(exploitDir, files, toSubmit, teams)
			}()
		}
		//Wait workers
		wg.Wait()
	}
}

func exploit(exploitDir string, exploits []os.FileInfo, toSubmit chan<- string, teams <-chan string) {
	// Read from teams channel
	for team := range teams {
		// For every exploit
		for _, exploitInfo := range exploits {
			// Execute exploit and get output
			exploitName := exploitInfo.Name()
			outFlags, err := exec.Command(exploitDir+exploitName, team).Output()
			if err != nil {
				log.Fatalf("Error in script %s\nTrace:\n%s\n", exploitName, string(outFlags))
				return
			}
			//Test the format
			flags := strings.Split(string(outFlags), "\n")

			//Send the flags to the submitter goroutine!
			for _, flag := range flags {
				toSubmit <- flag
			}
		}
	}
	return

}
