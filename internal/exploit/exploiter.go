package exploit

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"sync"
	"sync/atomic"
	"time"
)

type Flag struct {
	Flag    string
	Team    string
	Exploit string
}

func StartExploiter(exploitCtx context.Context, wg *sync.WaitGroup) {
	//Every tick!
	defer wg.Done()
	tick := exploitCtx.Value("tick").(int)
	teamDir := exploitCtx.Value("teamDir").(string)
	threshold := exploitCtx.Value("threshold").(int)
	exploitDir := exploitCtx.Value("exploitDir").(string)
	workers := exploitCtx.Value("workers").(int)
	toSubmit := exploitCtx.Value("submit").(chan Flag)
	timeout := exploitCtx.Value("timeout").(int)
	flagRegex, err := regexp.Compile(exploitCtx.Value("flagRegex").(string))

	if err != nil {
		log.Fatalf("EXPLOITER:\t %s is an invalid regexp\n", exploitCtx.Value("flagRegex").(string))
	}

	round := 1
	//base values

	//teamsMap := make(map[string] sync.Map)
	teamsMap := make(map[string]sync.Map)
	for {
		startTick := time.Now()
		//Get the producer of the teams
		//teams := GetTeamAsChan(fileTeam)
		log.Printf("==========\tStarting round %d\t=============\n", round)
		teamsFiles, err := ioutil.ReadDir(teamDir)
		teamsChan := make(map[string]chan string)
		for _, teamFile := range teamsFiles {
			teamNameFile := strings.Split(teamFile.Name(), ".")[0]
			//team effettivi
			teams := sync.Map{}
			// per ogni team nel file
			//todo implementazione molto naive, ma in questo modo posso aggiornare il file dei team esternamenti senza
			// perdere informazioni
			for _, team := range ReadTeams(teamDir + teamFile.Name()) {
				// provo a vedere se il team exploit era gia' stato inserito
				dic, ok := teamsMap[teamNameFile]
				var newval int32 = 0
				if ok {
					//guardo se il team era gia' stato salvato
					val, ok := dic.Load(team)
					// in caso positivo mi salvo il vecchio valore
					if ok {
						teams.Store(team, val)
					} else {
						teams.Store(team, &newval)
					}
				} else {
					teams.Store(team, &newval)

				}

			}
			//aggiorno la mappa base
			teamsMap[teamNameFile] = teams
			// e mi creo il canale effettivo
			teamsChan[teamNameFile] = Team2Chan(teams, threshold)
		}

		// Read all files in directory
		files, err := ioutil.ReadDir(exploitDir)
		if err != nil {
			log.Fatalf("EXPLOITER:\tDirectory %s doesn't exist!\n", exploitDir)

		}
		//Init waitgroup to wait for children
		wg := sync.WaitGroup{}
		wg.Add(workers)
		//StartExploiter workers
		for i := 0; i < workers; i++ {
			go exploitWorker(i, exploitDir, files, toSubmit, teamsChan, &wg, flagRegex, timeout, teamsMap)
		}
		//Wait workers
		wg.Wait()
		log.Printf("==========\tRound %d terminated!\t=============\n", round)
		//Stop until start_tick+tick
		if time.Now().Before(startTick.Add(time.Duration(tick) * time.Second)) {
			<-time.Tick(time.Until(startTick.Add(time.Duration(tick) * time.Second)))
		}
		round++
	}
}

func exploitWorker(id int, exploitDir string, exploits []os.FileInfo, toSubmit chan<- Flag,
	teamsChan map[string]chan string, wg *sync.WaitGroup, flagRegex *regexp.Regexp, timeout int, teamMap map[string]sync.Map) {
	defer wg.Done()
	// Read from teams channel
	// let's start from a different point
	rand.Seed(time.Now().UnixNano())
	rand.Shuffle(len(exploits), func(i, j int) { exploits[i], exploits[j] = exploits[j], exploits[i] })
	// For every exploit
	for _, exploitInfo := range exploits {
		exploitName := exploitInfo.Name()
		teamName := strings.Split(exploitName, ".")[0]
		teams, ok := teamsChan[teamName]
		if !ok {
			fmt.Printf("EXPLOITER %d\t NO TEAM FILE FOR EXPLOIT %s \n", id, exploitInfo.Name())
		}
		select {
		// i have teams to test
		case team := <-teams:
			teamExpl := teamMap[teamName]
			val, _ := teamExpl.Load(team)
			// Execute exploit and get output
			exploitAbsPath := fmt.Sprintf("%s%s", exploitDir, exploitName)
			//Executing command
			out, err := executeExploit(exploitAbsPath, team, timeout)
			if err {
				atomic.AddInt32(val.(*int32), 1)
				continue
			}
			flags := strings.Split(out, "\n")
			//Send the flags to the submitter goroutine!
			result := false
			for _, flagVal := range flags {
				if flagVal == "" {
					continue
				}
				matched := flagRegex.MatchString(flagVal)
				if matched {
					toSubmit <- Flag{flagVal, team, exploitName}
					result = true
				} else {
					log.Printf("EXPLOITER %d:\t Flag %s doesn't match the regex!\n", id, flagVal)
				}
			}

			if result {
				//settare a 0 il valore della matrice
				atomic.StoreInt32(val.(*int32), 0)
			} else {
				atomic.AddInt32(val.(*int32), 1)
			}
		// next exploit please
		default:
			continue
		}
	}
	return

}

func executeExploit(command string, team string, timeout int) (string, bool) {
	err := os.Chmod(command, 0700)

	crashExploit := false
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeout)*time.Second)
	defer cancel() // The cancel should be deferred so resources are cleaned up

	// Create the command with our context
	cmd := exec.CommandContext(ctx, command, team)

	// This time we can simply use Output() to get the result.
	out, err := cmd.Output()
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	// We want to check the context error to see if the timeout was executed.
	// The error returned by cmd.Output() will be OS specific based on what
	// happens when a process is killed.
	if ctx.Err() == context.DeadlineExceeded {
		log.Printf("EXPLOITER:\tTIMEDOUT in %s team %s \nTrace:\n%s\n", command, team, err)
		crashExploit = true
	}

	// If there's no context error, we know the command completed (or errored).
	// fmt.Println("Output:", string(out))
	if err != nil {
		log.Printf("EXPLOITER:\tError in %s team %s \nTrace:\n%s\n", command, team, err)
		crashExploit = true
	}

	return string(out), crashExploit
}
