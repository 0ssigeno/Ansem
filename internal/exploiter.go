package internal

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"sync"
	"time"
)

func StartExploiter(exploitCtx context.Context, wg *sync.WaitGroup) {
	//Every tick!
	defer wg.Done()
	tick := exploitCtx.Value("tick").(int)
	teamDir := exploitCtx.Value("teamDir").(string)
	//threshold := exploitCtx.Value("threshold").(string)
	exploitDir := exploitCtx.Value("exploitDir").(string)
	workers := exploitCtx.Value("workers").(int)
	toSubmit := exploitCtx.Value("submit").(chan string)
	timeout := exploitCtx.Value("timeout").(int)
	flagRegex, err := regexp.Compile(exploitCtx.Value("flagRegex").(string))

	if err != nil {
		log.Fatalf("EXPLOITER:\t %s is an invalid regexp\n", exploitCtx.Value("flagRegex").(string))
	}

	round := 1
	for {
		start_tick := time.Now()
		//Get the producer of the teams
		//teams := GetTeamAsChan(fileTeam)
		log.Printf("==========\tStarting round %d\t=============\n", round)
		teams, err := ioutil.ReadDir(teamDir)
		teamsChan := make(map[string]chan string)
		for _, team := range teams {
			teamsChan[strings.Split(team.Name(), ".")[0]] = GetTeamAsChan(teamDir + team.Name())
		}

		// Read all files in directory
		files, err := ioutil.ReadDir(exploitDir)
		if err != nil {
			log.Fatalf("EXPLOITER:\tDirectory %s doesn't exist!\n", exploitDir)

		}
		//Init waitgroup to wait for children
		wg := sync.WaitGroup{}
		wg.Add(workers)
		//StartExploiter workers
		for i := 0; i < workers; i++ {
			go exploitWorker(i, exploitDir, files, toSubmit, teamsChan, &wg, flagRegex, timeout)
		}
		//Wait workers
		wg.Wait()
		log.Printf("==========\tRound %d terminated!\t=============\n", round)
		//Stop until start_tick+tick
		if time.Now().Before(start_tick.Add(time.Duration(tick) * time.Minute)) {
			<-time.Tick(time.Until(start_tick.Add(time.Duration(tick) * time.Minute)))
		}
		round++
	}
}

func exploitWorker(id int, exploitDir string, exploits []os.FileInfo, toSubmit chan<- string, teamsChan map[string]chan string, wg *sync.WaitGroup, flagRegex *regexp.Regexp, timeout int) {
	defer wg.Done()
	// Read from teams channel
	// let's start from a different point
	rand.Seed(time.Now().UnixNano())
	rand.Shuffle(len(exploits), func(i, j int) { exploits[i], exploits[j] = exploits[j], exploits[i] })
	// For every exploit
	for _, exploitInfo := range exploits {
		exploitName := exploitInfo.Name()
		teams, ok := teamsChan[strings.Split(exploitName, ".")[0]]
		if !ok {
			fmt.Println("NO TEAM FILE FOR EXPLOIT ", exploitInfo.Name())
		}
		select {
		// i have teams to test
		case team := <-teams:
			// Execute exploit and get output
			exploitAbsPath := fmt.Sprintf("%s%s", exploitDir, exploitName)
			//Executing command
			out, err := executeExploit(exploitAbsPath, team, timeout)

			if err {
				continue
			}
			flags := strings.Split(out, "\n")
			//Send the flags to the submitter goroutine!
			for _, flag := range flags {
				if flag == "" {
					continue
				}
				matched := flagRegex.MatchString(flag)
				if matched {
					toSubmit <- flag
				} else {
					log.Printf("EXPLOITER:\t Flag %s doesn't match the regex!\n", flag)
				}
			}
		// next exploit please
		default:
			continue
		}
	}
	return

}

func executeExploit(command string, team string, timeout int) (string, bool) {
	os.Chmod(command, 0700)
	contFlag := false

	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeout)*time.Second)
	defer cancel() // The cancel should be deferred so resources are cleaned up

	// Create the command with our context
	cmd := exec.CommandContext(ctx, command, team)

	// This time we can simply use Output() to get the result.
	out, err := cmd.Output()
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	// We want to check the context error to see if the timeout was executed.
	// The error returned by cmd.Output() will be OS specific based on what
	// happens when a process is killed.
	if ctx.Err() == context.DeadlineExceeded {
		log.Printf("EXPLOITER:\tTIMEDOUT in %s team %s \nTrace:\n%s\n", command, team, err)
		contFlag = true
		return string(out), contFlag
	}

	// If there's no context error, we know the command completed (or errored).
	// fmt.Println("Output:", string(out))
	if err != nil {
		log.Printf("EXPLOITER:\tError in %s team %s \nTrace:\n%s\n", command, team, err)
		contFlag = true
	}

	return string(out), contFlag
}
