package internal

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"sync"
	"time"
)

func StartExploiter(exploitCtx context.Context, wg *sync.WaitGroup) {
	//Every tick!
	defer wg.Done()
	tick := exploitCtx.Value("tick").(int)
	fileTeam := exploitCtx.Value("fileTeam").(string)
	exploitDir := exploitCtx.Value("exploitDir").(string)
	workers := exploitCtx.Value("workers").(int)
	toSubmit := exploitCtx.Value("submit").(chan string)
	flagRegex, err := regexp.Compile(exploitCtx.Value("flagRegex").(string))

	if err != nil {
		log.Fatalf("EXPLOITER:\t %s is an invalid regexp\n", exploitCtx.Value("flagRegex").(string))
	}

	round := 1
	for {
		now := time.Now()
		//Get the producer of the teams
		teams := GetTeamAsChan(fileTeam)
		// Read all files in directory
		files, err := ioutil.ReadDir(exploitDir)
		if err != nil {
			log.Fatalf("EXPLOITER:\tDirectory %s doesn't exist!\n", exploitDir)

		}
		//Init waitgroup to wait for children
		wg := sync.WaitGroup{}
		wg.Add(workers)
		//StartExploiter workers
		log.Printf("==========\tStarting round %d\t=============\n", round)
		for i := 0; i < workers; i++ {
			go exploit(i, exploitDir, files, toSubmit, teams, &wg, flagRegex)
		}
		//Wait workers
		wg.Wait()
		log.Printf("==========\tRound %d terminated!\t=============\n", round)
		//Stop until now+tick
		<-time.Tick(time.Until(now.Add(time.Duration(tick))))
		round++
	}
}

func exploit(id int, exploitDir string, exploits []os.FileInfo, toSubmit chan<- string, teams <-chan string, wg *sync.WaitGroup, flagRegex *regexp.Regexp) {
	defer wg.Done()
	// Read from teams channel
	for team := range teams {
		// For every exploit
		for _, exploitInfo := range exploits {

			// Execute exploit and get output
			exploitName := exploitInfo.Name()
			log.Printf("Worker %d: Executing %s against %s...\n", id, exploitName, team)
			exploitAbsPath := fmt.Sprintf("%s%s", exploitDir, exploitName)

			//Executing command
			out, contFlag := ExecuteCommand(exploitAbsPath, team)

			if contFlag {
				continue
			}
			flags := strings.Split(out, "\n")
			//Send the flags to the submitter goroutine!
			for _, flag := range flags {
				matched := flagRegex.MatchString(flag)
				if matched && flag != "" {
					toSubmit <- flag
				} else {
					log.Printf("EXPLOITER:\t Flag %s doesn't match the regex!\n", flag)
				}
			}
		}
	}
	return

}

func ExecuteCommand(command string, team string) (string, bool) {
	os.Chmod(command, 0700)
	cmd := exec.Command(command, team)
	var out bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr
	err := cmd.Run()
	contFlag := false
	if err != nil {
		log.Printf("EXPLOITER:\tError in %s\nTrace:\n%s\n", command, stderr.String())
		contFlag = true
	}
	return out.String(), contFlag
}
